import java_cup.runtime.*;
parser code {:
//----------------------------------Funções de erro----------------------------------
    public void report_error(String message, Object info)  {
        // Obtém o número da linha onde ocorreu o erro
        int line = ((Symbol) info).left;
        // Obtém o token que causou o erro
        Symbol tokenSymbol = (Symbol) info;
        String token = tokenSymbol.value.toString();
        
        // Especifica o tipo de erro e o contexto
        String errorMessage = "Syntax Error at line " + (line + 1 ) + " - Token: " + token +"      |"+ message;
        System.out.println(errorMessage);
    }

    public void report_fatal_error(String message, Object info)  {
        // Obtém o número da linha onde ocorreu o erro
        int line = ((Symbol) info).left;
        // Obtém o token que causou o erro
        Symbol tokenSymbol = (Symbol) info;
        String token = tokenSymbol.value.toString();
        
        // Especifica o tipo de erro e o contexto
        String errorMessage = "Syntax Error at line " + (line + 1) + " - Token: " + token +"      |"+ message;
        System.out.println(errorMessage);
        System.exit(-1);
    }

:}

/*definindo scan*/
scan with {: return super.scan(); :};

/*----------------------------------TOKENS----------------------------------*/
terminal String SOME, ALL, VALUE, MIN, MAX, EXACTLY, THAT, NOT, AND, OR, ONLY, CLASS_COLON, EQUIVALENT_TO_COLON, INDIVIDUALS_COLON, SUBCLASS_OF_COLON;
terminal String DISJOINT_CLASSES_COLON, CLASS_IDENTIFIERS, INDIVIDUAL_NAME, PROPERTY_IDENTIFIERS, NAMESPACE_OWL, NAMESPACE_RDFS, NAMESPACE_XSD;
terminal String COMMENT, LEFT_BRACE, RIGHT_BRACE, LEFT_PAREN, RIGHT_PAREN, LEFT_BRACKET, RIGHT_BRACKET, GREATER_THAN, LESS_THAN, EQUAL, EQUAL_LESS_THAN;
terminal String EQUAL_GREATER_THAN, DOUBLE_QUOTE, BROKEN_LINE, COMMA, SSN, CLASS_IDENTIFERS, INTEGER, FLOAT, STRING, COLON, INVERSE;
terminal Float CARDINALITY_FLOAT;
terminal Integer CARDINALITY_INTEGER; 
/*----------------------------------PRODUÇÕES----------------------------------*/
non terminal Object ClassOwl, ClassHeader, DisjointClasses, DisjointClassesDescription,DisjointClassesList,IndividualsDescription;
non terminal Object IndividualsList, DisjointAndIndividuals,PrimitiveClass, PrimitiveClassBody, PrimitiveClassBodyDescription, PrimitiveClassBodyList, LogicalConnector;
non terminal Object PrimitiveClassBodyListItem, PrimitiveSomeItem, DataType, DataTypeInteger, DataTypeFloat, DataTypeString, Individuals;
non terminal Object NameSpaceHeader, SubClassOfPrimitiveClass, PrimitiveClassBodyListItemPair, Property, ComparissonSign, Quantifier, EquivalentTo;
precedence left NOT, AND, OR;   
start with ClassOwl;

ClassOwl::= PrimitiveClass ClassOwl | error | /*e*/;
ClassHeader::= CLASS_COLON CLASS_IDENTIFIERS:i {:System.out.println("=========================\n" + "Nova classe detectada: " + i);:};


DisjointClasses::= DISJOINT_CLASSES_COLON DisjointClassesDescription | /*e*/;
DisjointClassesDescription::= DisjointClassesList | /*e*/;
DisjointClassesList::= CLASS_IDENTIFIERS COMMA DisjointClassesList | CLASS_IDENTIFIERS;
Individuals::= INDIVIDUALS_COLON IndividualsDescription | /*e*/;
IndividualsDescription::= IndividualsList | /*e*/;
IndividualsList::= INDIVIDUAL_NAME COMMA IndividualsList | INDIVIDUAL_NAME; 
DisjointAndIndividuals::= DisjointClasses Individuals;

Property::= PROPERTY_IDENTIFIERS:p {:System.out.println("Nova propriedade detectada: " + p);:} | SSN:s {:System.out.println("Nova propriedade detectada: " + s);:}; 
LogicalConnector::= AND:a {:System.out.println("Conectivo lógico encontrado: " + a);:} | OR:o {:System.out.println("Conectivo lógico encontrado: " + o);:} | NOT:n {:System.out.println("Conectivo lógico encontrado: " + n);:};
PrimitiveSomeItem::= CLASS_IDENTIFIERS:c {:System.out.println("Classe como propriedade encontrada" + c + "\n" + "\n---OBJECT PROPERTY---\n");:} | DataType {:System.out.println("\n---DATA PROPERTY---\n");:} | LEFT_PAREN PrimitiveClassBodyListItem RIGHT_PAREN;
DataType::= DataTypeInteger | DataTypeFloat | DataTypeString;
DataTypeInteger::= NameSpaceHeader COLON INTEGER:i {:System.out.println("Type integer encontrado: " + i);:} | NameSpaceHeader COLON INTEGER:i {:System.out.println("Type integer encontrado: " + i);:} LEFT_BRACKET ComparissonSign CARDINALITY_INTEGER:c {:System.out.println("Inteiro encontrado: " + c);:} RIGHT_BRACKET;
DataTypeFloat::= NameSpaceHeader COLON FLOAT:f {:System.out.println("Type float encontrado: " + f);:} | NameSpaceHeader COLON FLOAT:f {:System.out.println("Type float encontrado: " + f);:} LEFT_BRACKET ComparissonSign CARDINALITY_FLOAT:c {:System.out.println("Float encontrado: " + c);:} RIGHT_BRACKET;
DataTypeString::= NameSpaceHeader COLON STRING:s {:System.out.println("Type string encontrado: " + s);:};
ComparissonSign::= GREATER_THAN | LESS_THAN | EQUAL | EQUAL_LESS_THAN | EQUAL_GREATER_THAN; 
NameSpaceHeader::= NAMESPACE_OWL:o {:System.out.println("Namespace encontrado: " + o);:} | NAMESPACE_RDFS:r {:System.out.println("Namespace encontrado: " + r);:} | NAMESPACE_XSD:x {:System.out.println("Namespace encontrado: " + x);:};

PrimitiveClass::= ClassHeader PrimitiveClassBody DisjointAndIndividuals {:System.out.println("\n---!!Classe primitiva!!---\n");:};
PrimitiveClassBody::= SubClassOfPrimitiveClass;
SubClassOfPrimitiveClass::= SUBCLASS_OF_COLON PrimitiveClassBodyDescription;
PrimitiveClassBodyDescription::= PrimitiveClassBodyList | /*e*/;
PrimitiveClassBodyList::= PrimitiveClassBodyListItem COMMA PrimitiveClassBodyList | PrimitiveClassBodyListItem | PrimitiveClassBodyListItem LogicalConnector PrimitiveClassBodyList;
PrimitiveClassBodyListItem::= CLASS_IDENTIFIERS:c {:System.out.println("Classe como propriedade encontrada: " + c);:} | Property Quantifier PrimitiveSomeItem | LEFT_PAREN PrimitiveClassBodyListItem RIGHT_PAREN PrimitiveClassBodyListItemPair;
Quantifier::= SOME | ALL;


PrimitiveClassBodyListItemPair::= LogicalConnector PrimitiveClassBodyListItem | /*e*/;