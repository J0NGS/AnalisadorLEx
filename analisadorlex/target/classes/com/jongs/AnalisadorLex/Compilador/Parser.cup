import java_cup.runtime.*;
parser code {:
//----------------------------------Funções de erro----------------------------------
    public void report_error(String message, Object info)  {
        // Obtém o número da linha onde ocorreu o erro
        int line = ((Symbol) info).left;
        // Obtém o token que causou o erro
        Symbol tokenSymbol = (Symbol) info;
        String token = tokenSymbol.value.toString();
        
        // Especifica o tipo de erro e o contexto
        String errorMessage = "Syntax Error at line " + (line + 1 ) + " - Token: " + token +"      |"+ message;
        System.out.println(errorMessage);
    }

    public void report_fatal_error(String message, Object info)  {
        // Obtém o número da linha onde ocorreu o erro
        int line = ((Symbol) info).left;
        // Obtém o token que causou o erro
        Symbol tokenSymbol = (Symbol) info;
        String token = tokenSymbol.value.toString();
        
        // Especifica o tipo de erro e o contexto
        String errorMessage = "Syntax Error at line " + (line + 1) + " - Token: " + token +"      |"+ message;
        System.out.println(errorMessage);
        System.exit(-1);
    }

:}

/*definindo scan*/
scan with {: return super.scan(); :};

/*----------------------------------TOKENS----------------------------------*/
terminal String SOME, ALL, VALUE, MIN, MAX, EXACTLY, THAT, NOT, AND, OR, ONLY, CLASS_COLON, EQUIVALENT_TO_COLON, INDIVIDUALS_COLON, SUBCLASS_OF_COLON;
terminal String DISJOINT_CLASSES_COLON, CLASS_IDENTIFIERS, INDIVIDUAL_NAME, PROPERTY_IDENTIFIERS, NAMESPACE_OWL, NAMESPACE_RDFS, NAMESPACE_XSD;
terminal String COMMENT, LEFT_BRACE, RIGHT_BRACE, LEFT_PAREN, RIGHT_PAREN, LEFT_BRACKET, RIGHT_BRACKET, GREATER_THAN, LESS_THAN, EQUAL, EQUAL_LESS_THAN;
terminal String EQUAL_GREATER_THAN, DOUBLE_QUOTE, BROKEN_LINE, COMMA, SSN, CLASS_IDENTIFERS, INTEGER, FLOAT, STRING, COLON;
terminal Float CARDINALITY_FLOAT;
terminal Integer CARDINALITY_INTEGER; 
/*----------------------------------PRODUÇÕES----------------------------------*/
non terminal Object Class, ClassHeader, SubClassOf, SubClassOfList, SubClassOfItem, ExprSubClassOf, ExprSubClassOfSome, PropertyIdentifiers, SubClassOfSomeItemExpr;
non terminal Object DataType, Type, NameSpaceHead, ComparisonOperator, Cardinality, DisjointClasses, DisjointClassesList, Individuals, IndividualsList, DisjointAndIndividuals;
non terminal Object PrimitiveClass, PrimitiviClassBody, SubClassOfDescription, SubClassOIList, Expr, LogicalExpr, QuantifierExpr, CardinalityExpr, PropertyExpr, Property;
non terminal Object QuantifierConnector, CardinalityConnector, LogicalConnector, LogicalExprItem, QuantifierExprItem, CardinalityExprItem;

start with Class;
Class::= PrimitiveClass Class | error |/*e*/;
ClassHeader::= CLASS_COLON CLASS_IDENTIFIERS:i {:System.out.println("=========================\n" + "Nova classe detectada: " + i);:};

SubClassOf::= SUBCLASS_OF_COLON SubClassOfDescription;
SubClassOfDescription::= SubClassOfList| /*e*/;
SubClassOfList::= SubClassOfItem | SubClassOfItem COMMA SubClassOfList; 
SubClassOfItem::= CLASS_IDENTIFIERS | Expr;

Expr::= LogicalExpr | PropertyExpr;

PropertyExpr::= QuantifierExpr | CardinalityExpr;
QuantifierExpr::= Property QuantifierConnector QuantifierExprItem;
QuantifierExprItem::= CLASS_IDENTIFIERS | DataType | DataType LEFT_BRACKET ComparisonOperator Cardinality RIGHT_BRACKET | LEFT_PAREN PropertyExpr RIGHT_PAREN;
QuantifierConnector::= SOME | ALL | VALUE;

CardinalityExpr::= Property CardinalityConnector Cardinality CardinalityExprItem;
CardinalityExprItem::= CLASS_IDENTIFIERS | DataType | DataType LEFT_BRACKET ComparisonOperator Cardinality RIGHT_BRACKET | LEFT_PAREN PropertyExpr RIGHT_PAREN;
CardinalityConnector::= MIN | MAX | EXACTLY;
Property::= PROPERTY_IDENTIFIERS:p {:System.out.println("\nNova propriedade detectada: " + p);:} | SSN:s{:System.out.println("\nNova propriedade detectada: " + s);:};

LogicalExpr::= LogicalExprItem LogicalConnector LogicalExprItem {:System.out.println("\n---!!Operação lógica!!---");:}; 
LogicalConnector::= NOT:n {:System.out.println("\nOperador lógico detectado: " + n);:} | AND:a {:System.out.println("\nOperador lógico detectado: " + a);:} | OR:o {:System.out.println("\nOperador lógico detectado: " + o);:};
LogicalExprItem::= CLASS_IDENTIFIERS:c {:System.out.println("\nitem de expressão lógica: " + c);:} | LEFT_PAREN Expr RIGHT_PAREN {:System.out.println("\nExpressão como item de expressão lógica");:};

DataType::= NameSpaceHead COLON Type;
Type::= INTEGER | FLOAT | STRING;
NameSpaceHead::= NAMESPACE_OWL | NAMESPACE_RDFS | NAMESPACE_XSD;
ComparisonOperator::= GREATER_THAN | LESS_THAN | EQUAL | EQUAL_LESS_THAN | EQUAL_GREATER_THAN;
Cardinality::= CARDINALITY_INTEGER | CARDINALITY_FLOAT;

DisjointClasses::= DISJOINT_CLASSES_COLON DisjointClassesList | /*e*/;
DisjointClassesList::= CLASS_IDENTIFIERS COMMA DisjointClassesList | CLASS_IDENTIFIERS | /*e*/;
Individuals::= INDIVIDUALS_COLON IndividualsList | /*e*/;
IndividualsList::= INDIVIDUAL_NAME COMMA IndividualsList | INDIVIDUAL_NAME | /*e*/; 
DisjointAndIndividuals::= DisjointClasses Individuals;

PrimitiveClass::= ClassHeader PrimitiviClassBody {:System.out.println("\n---!!Classe primitiva!!---");:};
PrimitiviClassBody::= SubClassOf DisjointAndIndividuals;
